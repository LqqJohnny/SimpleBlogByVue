webpackJsonp([1],{"+gQr":function(n,e){n.exports='<hr>\n<p>title: solr的简单使用-查询\ndate: 2017-12-22 10:01:07\ntags: [solr,java]</p>\n<h2 id="categories-solr">categories: solr</h2>\n\x3c!-- deleteAbove --\x3e\n<p>好久没写博客了 ，出差真是不太适合我这样的宅男。</p>\n\x3c!-- more --\x3e\n<h3 id="start">Start</h3>\n<p>前几天公司要写一个独立的 LBS 服务，用于另一个项目，Location Based Service  基于位置服务，提供地理位置信息，目前的需求是 ：</p>\n<ol>\n<li>根据名字获取地点坐标</li>\n<li>获取坐标周围的地点信息</li>\n</ol>\n<p>地理位置信息量一共有1500多万条，这还是我第一次接触到这么多的数据，最终选择了用solr来存取，因为 solr 可以很方便的用来获取某个地点附近地点查找 和范围查找等。</p>\n<p>对于没接触过solr的我来说 ，这也是一个挑战了 ， 网上能找到的 教程或者文档 还是很少的，因此只能一点点的看官方英文文档了。</p>\n<p>还是一如既往的选择了 spring 公司目前的项目也全都是用它 ，所以也没有其他选择了。</p>\n<h4 id="solr-">solr的基本使用</h4>\n<p>首先，在pom中加入这两个 jar包,solrj 的版本如果是6以上的话可能会遇到报错：</p>\n<pre><code class="lang-xml">&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt;\n    &lt;version&gt;2.1.3.RELEASE&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.solr&lt;/groupId&gt;\n    &lt;artifactId&gt;solr-solrj&lt;/artifactId&gt;\n    &lt;version&gt;5.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre>\n<p>然后，配置 application.xml：</p>\n<pre><code class="lang-xml">&lt;!-- 加载solr的属性配置文件 --&gt;\n&lt;context:property-placeholder location=&quot;classpath:solr.properties&quot; ignore-unresolvable=&quot;true&quot;/&gt;\n\n&lt;!-- spring连接solr查询company数据库的配置 --&gt;\n&lt;solr:solr-client id=&quot;geoQuery&quot; url=&quot;${solr.geoSearchUrl}&quot;/&gt;\n\n&lt;solr:repositories base-package=&quot;com.lqqppl.solr.impl&quot; solr-template-ref=&quot;geoQueryTemplate&quot;/&gt;\n\n&lt;bean id=&quot;geoQueryTemplate&quot; class=&quot;org.springframework.data.solr.core.SolrTemplate&quot;&gt;\n    &lt;constructor-arg index=&quot;0&quot; ref=&quot;geoQuery&quot;&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n</code></pre>\n<p>还有上面配置里需要的  solr.properties</p>\n<pre><code class="lang-xml">solr.geoSearchUrl=http://ip:port/solr/\n</code></pre>\n<p>尝试过把solr里对应的库民直接在这指定 但是会报错，原因还没找到，所以只能在代码里指定库名。</p>\n<p>接下来我写了一个 test测试类 来测试 solr的 模糊搜索和附近地点搜索：</p>\n<pre><code class="lang-java">\npublic class TestQuerySolr {\n\n    public static void main(String[] args)\n    {\n        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        SolrTemplate geoQueryTemplate= (SolrTemplate) ac.getBean(&quot;geoQueryTemplate&quot;);\n\n//        query(geoQueryTemplate);\n\n        near(geoQueryTemplate);\n\n    }\n    public static void query(SolrTemplate geoQueryTemplate){\n\n        Criteria criteria = new Criteria(&quot;name&quot;);\n        criteria.is(&quot;lqqppl&quot;);  // 相当于 where name = &#39;lqqppl&#39;\n\n        SimpleQuery query = new SimpleQuery();\n        query.addCriteria(criteria);\n        System.out.println(geoQueryTemplate.queryForPage(&quot;geo&quot;,query,GeoPosition.class).getContent().get(0).getLocation());\n    }\n\n    public static void near(SolrTemplate geoQueryTemplate){\n        SimpleQuery query = new SimpleQuery(&quot;*:*&quot;);\n        FilterQuery fq = new SimpleFilterQuery(new Criteria(&quot;location&quot;)\n                  .near(new Point(45.6504795,-111.0502501), new Distance(5)));\n        query.addFilterQuery(fq);\n//        query.addSort(new Sort(Direction.ASC,&quot;category&quot;));\n//        query.addGroupByField(&quot;category&quot;);\n//        query.setOffset(10);\n//        query.setRows(20);  //  设置 返回的数量的长度\n        Page&lt;GeoPosition&gt; res = geoQueryTemplate.queryForPage(&quot;geo&quot;, query, GeoPosition.class);\n        System.out.println(JSONArray.fromObject(res.getContent()));\n    }\n}\n</code></pre>\n<p>在查询中还可以给query 添加很多筛选条件  排序、groupBy、分页等功能。</p>\n<h4 id="simplequery-simplefilterquery-">SimpleQuery 和 SimpleFilterQuery 的区别：</h4>\n<p>SimpleQuery一般用于固定的条件 如 type=1;\nSimpleFilterQuery一般用于参数变化的 筛选 ，如传进了一个参数 name，要选出 username= name 的 那就用 SimpleFilterQuery。</p>\n<h3 id="end">END</h3>\n<p>最后 ，给出一些最近找到的一些 solr关于 LBS 方面的文章与文档：</p>\n<blockquote>\n<p>文章</p>\n</blockquote>\n<p><a href="http://itindex.net/detail/41691-solr-%E7%A9%BA%E9%97%B4-%E6%90%9C%E7%B4%A2">基于Solr的控件搜索</a>\n<a href="http://blog.csdn.net/awj3584/article/details/11760757">solr空间搜索实现附近酒店的搜索</a>\n<a href="http://blog.csdn.net/likemebee/article/details/78469002">如何使用Spring Data Solr搜索引擎进行开发</a>\n<a href="https://www.ibm.com/developerworks/cn/java/j-spatial/">使用 Apache Lucene 和 Solr 进行位置感知搜索</a></p>\n<blockquote>\n<p>文档</p>\n</blockquote>\n<p><a href="https://wiki.apache.org/solr/Solrj">Solr Wiki Solrj</a>\n<a href="https://docs.spring.io/spring-data/solr/docs/2.1.3.RELEASE/api/">Spring Data Solr</a>\n<a href="https://docs.spring.io/spring-data/solr/docs/3.0.2.RELEASE/reference/html/">Spring Data for Apache Solr</a></p>\n'},"2AXw":function(n,e){},"2DAM":function(n,e){n.exports='<hr>\n<p>title: &#39;js中的浅复制和深复制&#39;\ndate: 2017-10-26 17:11:18</p>\n<h2 id="tags-js-">tags: [js,深复制,浅复制]</h2>\n\x3c!-- deleteAbove --\x3e\n<p>在很多情况下，我们需要在不影响原数组的情况下 操作数组，这时候就需要对目标数组进行复制，下面看看 js 中复制的两种形式。</p>\n\x3c!--more--\x3e\n<h3 id="js-">js中的浅复制和深复制</h3>\n<h4 id="-">浅？深？</h4>\n<p>这个深浅 ，应该就是字面上的意思 ，复制的深浅。</p>\n<p>加入一个数组 有多层，浅复制的话 ，只是复制了这个 数组的第一层 ，数组里面的 还是指向原来数组里面对应的，修改了一个，两个数组都会改变</p>\n<pre><code class="lang-js">var one = [\n            [1,2,3],\n            [4,5,6],\n            [7,8,9]\n          ]\nvar two = one.slice();\n/** two\n [\n    [1,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n**/\n\ntwo[0][0] = 111;\n\n/** one two\n [\n    [111,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n这种影响只限于 修改原来数组已有的 部分 如果向 two里面新加一个，则不会影响one\n\n**/\n\ntwo.push([1,1,1])\n\n/** one ：\n [\n    [111,2,3],\n    [4,5,6],\n    [7,8,9]\n  ]\n\n   two :\n    [\n        [111,2,3],\n        [4,5,6],\n        [7,8,9],\n        [1,1,1]\n    ]\n\n**/\n</code></pre>\n<p>类似的还有对象。</p>\n<blockquote>\n<p>深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。</p>\n</blockquote>\n<p>为了避免这种现象 ，就需要使用 深复制，它能避免出现这种修改原数组的现象。</p>\n<p>接下来 看看 两种复制方式 的具体实现方法。</p>\n<h4 id="-">浅复制</h4>\n<ul>\n<li><strong>1-直接用 = </strong>：</li>\n</ul>\n<p>这种方法只使用与 字符串 或者数字的复制，数组或对象使用 = 是复制的引用，指向的还是同一个东西的。</p>\n<ul>\n<li><strong>2-数组</strong><ul>\n<li>slice()</li>\n<li>var b = [...a]; // 解构赋值</li>\n<li>Array.from //  ES6 新增的 Array 方法</li>\n<li>concat()</li>\n</ul>\n</li>\n</ul>\n<p>这种方法 适用于一阶数组 。二阶以上就不管用了。</p>\n<ul>\n<li><strong>3-对象</strong></li>\n</ul>\n<p>使用一层循环 把 目标对象里面的属性全都复制到一个新的对象里面去</p>\n<pre><code class="lang-js">var res = {};\nfor(var key in object){\n    res[key] = object[key];\n}\n</code></pre>\n<p>但是这只适用 于 一层 如果对象里面的某个属性的值 还是对象 ，那就不适用了。</p>\n<h4 id="-">深复制</h4>\n<p>深复制的情况一般见于 多阶数组或者多阶对象。</p>\n<p>无论是数组还是对象，都需要用循环和递归 来讲其中的每一个属性值 复制到另一个 数组或对象里面。</p>\n<p>下面这个方法可以深复制 数组或对象：</p>\n<pre><code class="lang-js">var cloneObj = function(obj){\n    var str, newobj = obj.constructor === Array ? [] : {};\n    if(typeof obj !== &#39;object&#39;){\n        return;\n    } else if(window.JSON){\n        str = JSON.stringify(obj), //系列化对象\n        newobj = JSON.parse(str); //还原\n    } else {\n        for(var i in obj){\n            newobj[i] = typeof obj[i] === &#39;object&#39; ?\n            cloneObj(obj[i]) : obj[i];\n        }\n    }\n    return newobj;\n};\n\n\n//  来源 https://www.zhihu.com/question/23031215\n</code></pre>\n<p><strong>还有一个特别的技巧</strong>：</p>\n<p>那就是 把对象转字符串在转对象：</p>\n<pre><code class="lang-js">var a =[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n];\n\nvar b =  JSON.parse(JSON.stringify(a));\n\nb[0][0] = 111;\n/*\n a :   [\n        [1,2,3],\n        [4,5,6],\n        [7,8,9]\n       ]\n\n b : [\n      [111,2,3],\n      [4,5,6],\n      [7,8,9]\n     ]\n\n*/\n</code></pre>\n<h4 id="-">总结</h4>\n<ol>\n<li>字符串 ，数字的 复制 用 = 就可以了</li>\n<li>一维数组 用 slice 、concat 、[...] 或者 Array.from 都可以</li>\n<li>多维数组 或 对象 普遍用神技  <code>JSON.parse(JSON.stringify());</code>\nof course 如果你不嫌麻烦的话 可以写一个递归的方法来深复制。</li>\n</ol>\n<blockquote>\n<p>2017/10/26 下午5:13:01 哞</p>\n</blockquote>\n'},"2VVp":function(n,e,t){"use strict";e.a={}},"50Ll":function(n,e){},"7dfn":function(n,e){},BEmW:function(n,e,t){"use strict";var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("div",{staticClass:"title"},[n._v("文章列表")]),n._v(" "),t("div",{staticClass:"articlesList"},n._l(n.list,function(e){return t("div",{staticClass:"article_item"},[t("router-link",{attrs:{target:"_blank",to:n.genUrl(e.name)}},[n._v(n._s(n.genTitle(e.name)))])],1)}))])},r=[],a={render:o,staticRenderFns:r};e.a=a},EPnm:function(n,e){},ESBp:function(n,e){n.exports='<hr>\n<p>title: 输入url之后发生了什么\ndate: 2017-09-28 16:25</p>\n<h2 id="tags-http-url-">tags: [HTTP,url]</h2>\n\x3c!-- deleteAbove --\x3e\n<p><strong>[转]</strong>  这是关于http的一些基础知识，了解这些知识还是很有必要的。</p>\n\x3c!-- more --\x3e\n<h3 id="-url-">输入 URL 后发生了什么</h3>\n<h4 id="1-http-">1.生成 HTTP 请求消息</h4>\n<p>浏览器会用 HTTP 协议生成请求消息去 web服务器请求资源，</p>\n<p>消息格式包括 请求行，请求头和请求体；</p>\n<p>对应的响应也有： 状态行 消息头 消息体</p>\n<p>这些在浏览器的network都能看到。</p>\n<h4 id="2-dns">2.DNS</h4>\n<p>DNS ： 域名服务系统  domain name systerm\n可以将域名 转换成ip地址。</p>\n<h4 id="3-">3.建立连接--三次握手</h4>\n<p>有了IP地址了，就要与服务器建立连接了（  但是链接服务器的工作不是浏览器来做的 而是委托操作系统的协议栈发送信息）。 用到的是  <strong>TCP 协议</strong></p>\n<h4 id="4-">4.网页请求与显示</h4>\n<p>建立连接之后  ，客户端就可以开始进行各种请求了</p>\n<h4 id="5-">5.断开连接--四次挥手</h4>\n<ul>\n<li><p>主机向服务器发送一个断开连接的请求（不早了，我该走了）；</p>\n</li>\n<li><p>服务器接到请求后发送确认收到请求的信号（知道了）；</p>\n</li>\n<li><p>服务器向主机发送断开通知（我也该走了）；</p>\n</li>\n<li><p>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；</p>\n</li>\n</ul>\n<blockquote>\n<p>转自 <a href="https://zhuanlan.zhihu.com/p/23155051">前端解忧杂货铺</a></p>\n<p>更详细的内容进这个<a href="https://zhuanlan.zhihu.com/p/28946087">传送阵</a></p>\n</blockquote>\n'},FHfX:function(n,e){n.exports='<hr>\n<p>title: Spring一些常用的注解\ndate: 2017-10-17 10:45</p>\n<h2 id="tags-spring-">tags: [Spring,注解]</h2>\n\x3c!-- deleteAbove --\x3e\n<p>注解，是spring的一大特色，功能十分强大，代码方便快捷。\n\x3c!--more--\x3e\n下面是 spring的 一些常用的注解关键词</p>\n<h4 id="-controller">@Controller</h4>\n<p>这个是最基础的 就是把一个 类 设置成一个 <strong>控制器</strong>.</p>\n<h4 id="-restcontroller">@RestController</h4>\n<p>和 @Controller    类似，也是定义一个控制器,可以看成是结合了@ResponseBody与@Controller注解的功能。</p>\n<p>这两个定义控制器方式的不同在于 ，两种控制器的返回数据格式不同。\nController 返回的是jsp页面 可以说是String，而 RestController返回的json / xml 等其他格式的数据，RestController 为一些 Restful webservice 提供了便捷 ，能实现只提供数据的接口。</p>\n<blockquote>\n<p>这两个注解一般放在class 前面，对整个class里面的接口生效。</p>\n</blockquote>\n<h4 id="-requestmapping">@RequestMapping</h4>\n<p>用来 映射请求路径，不多bb，上例子：</p>\n<pre><code class="lang-java">// 还可以加其他的参数\n    @RequestMapping(value = &quot;/index.htm&quot;, produces = &quot;text/html;charset=UTF-8&quot;)\n    public String index() {\n        return &quot;jsp/index&quot;;\n    }\n</code></pre>\n<h4 id="-pathvariable">@PathVariable</h4>\n<p>从 路径里面取出参数 ，还是上例子比较易懂：</p>\n<pre><code class="lang-java">    @RequestMapping(path=&quot;/test-{id}.htm&quot;)\n    public String indexID(@PathVariable String id,Model model){\n        model.addAttribute(&quot;id&quot;, id);\n        return &quot;jsp/index&quot;;\n    }\n</code></pre>\n<p>当 输入地址<code>/test-111.htm</code>的时候，加入model的id 值 为 111</p>\n<h4 id="-requestparam">@RequestParam</h4>\n<p>为接口指定所需的参数 ，默认是必须的参数 ，也可以用参数改为非必须</p>\n<pre><code class="lang-java">    @RequestMapping(value=&quot;/param.htm&quot; , method = RequestMethod.GET )\n    public String param(\n            @RequestParam(value=&quot;id&quot;,required = false) String id ,\n            @RequestParam(&quot;name&quot;) String name,\n            Model model){\n\n        model.addAttribute(&quot;id&quot;, id);\n        model.addAttribute(&quot;name&quot;, name);\n        return &quot;jsp/index&quot;;\n    }\n</code></pre>\n<p>在传参数的时候还有一种特殊情况，如果前端传的参数不确定，或者数量多，一个个的指定非常麻烦 ，这时候就用 Map吧</p>\n<pre><code class="lang-java">\n    @RequestMapping(value=&quot;/mapParam.htm&quot; , method = RequestMethod.GET )\n    public String mapParam(\n            @RequestParam Map&lt;String, String&gt; param,\n            Model model){\n        model.addAttribute(&quot;id&quot;, param.get(&quot;id&quot;));\n        model.addAttribute(&quot;name&quot;, param.get(&quot;name&quot;));\n        return &quot;jsp/index&quot;;\n    }\n</code></pre>\n<p>随便你传什么参数 ，我只从map里面取我需要的，没有就取到空 ，也不会报错</p>\n<h4 id="-sessionattributes">@SessionAttributes</h4>\n<p>这个是使用 session来保存数据的，通常的session的用法是通过 HttpSession 的实例来调用addAttribute() 来保存数据的 ，现在有了@SessionAttributes 便可以在类声明之前就指定 那几个字段需要保存到session：</p>\n<pre><code class="lang-java">@Controller\n@SessionAttributes(&quot;id&quot;)\npublic class indexController {\n    @RequestMapping(value=&quot;/param.htm&quot; , method = RequestMethod.GET )\n    public String param(\n            @RequestParam(value=&quot;id&quot;,required = false) String id ,\n            @RequestParam(&quot;name&quot;) String name,\n            Model model){\n\n        model.addAttribute(&quot;id&quot;, id);\n        model.addAttribute(&quot;name&quot;, name);\n        return &quot;jsp/index&quot;;\n    }\n}\n</code></pre>\n<p>在这个例子里面， id就被存入了session 而 name则没有被存入。</p>\n<p>使用了 SessionAttributes ，在清除session的时候 就需要使用特定的方法：</p>\n<pre><code>sessionStatus.setComplete();\n\n\n</code></pre><p>这个方法只能清除掉 用SessionAttributes 定义过的字段，其他用HttpSession加入session的字段不会被清除。</p>\n<pre><code class="lang-java">    @RequestMapping(value=&quot;/clearSession.htm&quot;)\n    public String clearSession(\n            SessionStatus sessionStatus){\n        sessionStatus.setComplete();  //  清除 @sessionAttributes 标记的session属性值\n        return &quot;jsp/session&quot;;\n    }\n</code></pre>\n<h4 id="-cookievalue">@CookieValue</h4>\n<p>有session 必然就有 Cookie了 ， 这个注解就是用来获取cookie里面的参数值的 ：</p>\n<pre><code class="lang-java">    @RequestMapping(value=&quot;/getCookie.htm&quot;)\n    public String getCookie(\n            @CookieValue(&quot;JSESSIONID&quot;) String sessionID\n            ,Model model){\n        model.addAttribute(&quot;id&quot;,sessionID);\n        return &quot;jsp/index&quot;;\n    }\n</code></pre>\n<h4 id="-requestheader">@RequestHeader</h4>\n<p>同上</p>\n<pre><code class="lang-java">    @RequestMapping(value=&quot;/getReqHead.htm&quot;)\n    public String getReqHead(\n            @RequestHeader(&quot;Accept-Encoding&quot;) String encode\n            ,Model model){\n        model.addAttribute(&quot;name&quot;,encode);\n        return &quot;jsp/index&quot;;\n    }\n</code></pre>\n<p>【待补充】</p>\n<blockquote>\n<p>参考</p>\n<ul>\n<li><a href="https://linesh.gitbooks.io/spring-mvc-documentation-linesh-translation/content/publish/21-3/3-defining-@requestmapping-handler-methods.html">Spring MVC 4.2.4.RELEASE 中文文档 -2.3.3</a></li>\n</ul>\n</blockquote>\n'},"HLh+":function(n,e){n.exports='<hr>\n<p>title: 虚拟节点VNode\ndate: 2017-10-10 15:25</p>\n<h2 id="tags-vue-vnode-">tags: [vue,VNode,虚拟节点,问题]</h2>\n\x3c!-- deleteAbove --\x3e\n<p>Virtual DOM （虚拟树） 大幅减少了DOM操作带来的重计算步骤。\n\x3c!--more--\x3e\n通过将对真是dom的操作，现在虚拟dom上操作完 再将最后的结果 替换到真是dom上去 极大提升了效率，减少了开销。</p>\n<h2 id="vnode">VNode</h2>\n<h3 id="vnode-">VNode基类</h3>\n<p>一个VNode 对象其实和真是的dom对象很类似的，但是却比原生的Dom节点元素少了很多不必要的属性，这也是操作 VNode 比 操作真是dom元素 更快的原因之一，因为真是dom节点的属性多，遍历一次所需的时间也更多 ，然而在实际dom修改中，大部分的属性都是不需要的。</p>\n<p>VNode 定义好之后，将会通过createElement方法 将其渲染成dom节点。</p>\n<p>展示部分VNode的源码，</p>\n<p>完整的源码在 <a href="https://github.com/vuejs/vue/blob/dev/src/core/vdom/vnode.js">这里</a></p>\n<p>对于VNode的各个属性的解释看 <a href="https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown">这里</a></p>\n<pre><code class="lang-js">export default class VNode {\n  tag: string | void;\n  data: VNodeData | void;\n  children: ?Array&lt;VNode&gt;;\n  text: string | void;\n  //......\n\n  // 构造函数\n  constructor (\n    tag?: string,\n    data?: VNodeData,\n    children?: ?Array&lt;VNode&gt;,\n    text?: string,\n    elm?: Node,\n    context?: Component,\n    componentOptions?: VNodeComponentOptions,\n    asyncFactory?: Function\n  ) {\n  // 初始化\n    this.tag = tag\n    this.data = data\n    this.children = children\n    // ......\n  }\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  get child (): Component | void {\n    return this.componentInstance\n  }\n}\n</code></pre>\n<p>可以看出 VNode其实就是一个存着 <strong>定义一个dom元素需要的各种属性</strong> 的 <em>对象</em></p>\n<p>举个例子：</p>\n<pre><code class="lang-js">{\n    tag: &#39;div&#39;\n    data: {\n        class: &#39;test&#39;\n    },\n    children: [\n        {\n            tag: &#39;a&#39;,\n            data: {\n                class: &#39;demo&#39;,\n                href: &#39;#&#39;\n            }\n            text: &#39;click me&#39;\n        }\n    ]\n}\n</code></pre>\n<p>调用 createElement() 之后，渲染的结果将会是 ：</p>\n<pre><code class="lang-html">&lt;div class=&quot;test&quot;&gt;\n    &lt;a class=&quot;demo&quot; href=&quot;#&quot;&gt;click me&lt;/a&gt;\n&lt;/div&gt;\n</code></pre>\n<h3 id="vnode-">VNode 的方法</h3>\n<p>接下来在看看 VNode的其他方法 ：</p>\n<pre><code class="lang-js">// 创建一个空 VNode对象\nexport const createEmptyVNode = (text: string = &#39;&#39;) =&gt; {\n  const node = new VNode()\n  node.text = text\n  node.isComment = true\n  return node\n}\n\n// 创建一个 文本对象\nexport function createTextVNode (val: string | number) {\n  return new VNode(undefined, undefined, undefined, String(val))\n}\n\n\n// 复制一个VNode对象\nexport function cloneVNode (vnode: VNode, deep?: boolean): VNode {\n  const cloned = new VNode(\n    vnode.tag,\n    vnode.data,\n    vnode.children,\n    vnode.text,\n    vnode.elm,\n    vnode.context,\n    vnode.componentOptions,\n    vnode.asyncFactory\n  )\n  cloned.ns = vnode.ns\n  cloned.isStatic = vnode.isStatic\n  cloned.key = vnode.key\n  cloned.isComment = vnode.isComment\n  cloned.isCloned = true\n  if (deep &amp;&amp; vnode.children) {\n    cloned.children = cloneVNodes(vnode.children)\n  }\n  return cloned\n}\n// 批量复制 VNode 本质是 循环调用  cloneVNode 方法\nexport function cloneVNodes (vnodes: Array&lt;VNode&gt;, deep?: boolean): Array&lt;VNode&gt; {\n  const len = vnodes.length\n  const res = new Array(len)\n  for (let i = 0; i &lt; len; i++) {\n    res[i] = cloneVNode(vnodes[i], deep)\n  }\n  return res\n}\n</code></pre>\n<p>以上 是 VNode  的源码内容 很好理解</p>\n<p>但是。。。</p>\n<p><strong>多次提到 createElement()方法 好像并没有呀。。。</strong></p>\n<p>其实  createElement 和 createComponent 已经被单独拿出来了 <a href="https://github.com/vuejs/vue/tree/dev/src/core/vdom">链接</a></p>\n<blockquote>\n<p>问题</p>\n</blockquote>\n<ul>\n<li>关于createElement ,createComponent 这两个方法还需要仔细的理解.</li>\n<li>对于VNode的一些常用到的属性可以稍微熟悉一下</li>\n</ul>\n<p>参考文章：</p>\n<ul>\n<li><a href="https://github.com/answershuto/learnVue/blob/master/docs/VNode%E8%8A%82%E7%82%B9.MarkDown">VNode节点-github</a></li>\n<li><a href="https://zhuanlan.zhihu.com/p/25630842">对 virtual-dom 的一些理解</a></li>\n</ul>\n'},HQu0:function(n,e){n.exports='<hr>\n<p>title: Spring 视图重定向\ndate: 2017/10/17 下午5:56:46</p>\n<h2 id="tags-spring-">tags: [Spring,重定向]</h2>\n\x3c!-- deleteAbove --\x3e\n<p>Spring 视图重定向 推荐两个用法：</p>\n<ul>\n<li>forward</li>\n<li>redirect</li>\n</ul>\n<p>来看看这个两个方式的同与异\n\x3c!--- more--\x3e</p>\n<h2 id="spring-">Spring视图重定向</h2>\n<h3 id="redirect">redirect</h3>\n<pre><code class="lang-javascript">@RequestMapping(value = &quot;redirect.htm&quot;)\npublic String home(){\n    return &quot;redirect:index.htm&quot;;\n}\n</code></pre>\n<p>原理：controller 返回的视图名中有  <em>redirect:</em>   这个前缀就会被检测到，其后面的 url地址 会被解析成重定向url。然后会发送一个写信息给 客户端(浏览器)，告诉它要重定向到这个地址去。</p>\n<p>所以，这是一个<strong>客户端行为</strong> .</p>\n<h3 id="forward">forward</h3>\n<pre><code class="lang-javascript">@RequestMapping(value = &quot;forward.htm&quot;)\npublic String home1(){\n    return &quot;forward:index.htm&quot;;\n}\n</code></pre>\n<p>代码是一样的，效果也是一样的。但是原理是不一样的 ：</p>\n<p>forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址。</p>\n<p>这是一个 <strong>服务器行为</strong></p>\n<h3 id="-">总结</h3>\n<h4 id="-">同</h4>\n<ul>\n<li>效果相同，看到的视图一样</li>\n</ul>\n<h4 id="-">异</h4>\n<ul>\n<li>原理不同 ，forward是服务器行为  redirect是客户端行为</li>\n<li>地址栏显示地址不同 ，redirect显示的是网页真是的地址，forward 显示的就是当前控制器匹配到的地址。</li>\n</ul>\n<p>forward就像我现在写的这个笔记一样，我不告诉你这里的部分内容摘自哪里。\n我把部分原文内容抄过来 ，自己还可以做一些修改。</p>\n<p>redirect 就像我直接给你一个地址 ，你直接去他那个地址了，和我无关了。</p>\n<blockquote>\n<p><em>2017/10/18 上午9:45:12 -- 哞 </em></p>\n</blockquote>\n'},Hzjv:function(n,e){n.exports=[{type:"file",name:"2017年10月书单.md",title:" 2017年10月书单",date:" 2017-10-27 14",tags:" 书单",categories:" reading"},{type:"file",name:"hexo设置canvas背景.md",title:" hexo设置canvas背景",date:" 2017-11-13 11",tags:" hexo",categories:" hexo"},{type:"file",name:"jsonp跨域请求的封装.md",title:" jsonp跨域请求的方法封装",date:" 2017-09-27 15",tags:" js,jsonp"},{type:"file",name:"js中不同数据类型的加法.md",title:" js中不同数据类型的加法",date:" 2017-09-27 17",tags:" js,数据类型"},{type:"file",name:"js中的this.md",title:" js中的this",date:" 2017-09-28 13",tags:" js,this"},{type:"file",name:"js中的浅复制和深复制.md",title:" 'js中的浅复制和深复制'",date:" 2017-10-26 17",tags:" js,深复制,浅复制"},{type:"file",name:"solr的简单使用-插入.md",title:" solr的简单使用-插入",date:" 2017-12-22 10",tags:" solr,java",categories:" solr"},{type:"file",name:"solr的简单使用.md",title:" solr的简单使用-查询",date:" 2017-12-22 10",tags:" solr,java",categories:" solr"},{type:"file",name:"Spring一些常用的注解.md",title:" Spring一些常用的注解",date:" 2017-10-17 10",tags:" Spring,注解"},{type:"file",name:"Spring视图重定向.md",title:" Spring 视图重定向",date:" 2017/10/17 下午5",tags:" Spring,重定向"},{type:"file",name:"vue深入响应式原理.md",title:" vue深入响应式原理",date:" 2017-10-9 15",tags:" vue,响应式,问题"},{type:"file",name:"webpack配置各种loader.md",title:" webpack配置各种loader",date:" 2017-11-07 10",tags:" webpack"},{type:"file",name:"虚拟节点VNode.md",title:" 虚拟节点VNode",date:" 2017-10-10 15",tags:" vue,VNode,虚拟节点,问题"},{type:"file",name:"输入url之后发生了什么.md",title:" 输入url之后发生了什么",date:" 2017-09-28 16",tags:" HTTP,url"}]},IlUV:function(n,e,t){"use strict";var o=function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},r=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"header"},[t("div",{staticClass:"siteName"},[n._v(" 网站名称 ")])])}],a={render:o,staticRenderFns:r};e.a=a},JWwo:function(n,e){},M93x:function(n,e,t){"use strict";function o(n){t("oFz+")}var r=t("n8Kv"),a=t("i3Kz"),s=t("ngHh"),i=o,l=s(r.a,a.a,!1,i,null,null);e.a=l.exports},Mitt:function(n,e,t){"use strict";function o(n){t("50Ll")}var r=t("SsN4"),a=t("IlUV"),s=t("ngHh"),i=o,l=s(r.a,a.a,!1,i,"data-v-127d1b4e",null);e.a=l.exports},NHnr:function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var o=t("O534"),r=t("M93x"),a=t("YaEn"),s=t("vAWj");o.a.use(s.a),o.a.config.productionTip=!1,new o.a({el:"#app",router:a.a,template:"<App/>",components:{App:r.a}})},NJ3n:function(n,e){n.exports='<hr>\n<p>title: jsonp跨域请求的方法封装\ndate: 2017-09-27 15:38</p>\n<h2 id="tags-js-jsonp-">tags: [js,jsonp]</h2>\n\x3c!-- deleteAbove --\x3e\n<p>talk is cheap ,show me your code!</p>\n\x3c!--more--\x3e\n<pre><code class="lang-js">function jsonp (options) {\n    let url = options.url\n    let data = options.data\n\n    let oBody = document.getElementsByTagName(&#39;body&#39;)[0]\n    let oScript = document.createElement(&#39;script&#39;)\n\n    let callbackName = &#39;cb&#39; + (~~(Math.random()*0xffffff)).toString(16)\n    window[callbackName] = function (result) {\n        options.success(result) ; //  将传入的success 方法存入window\n    }\n    data[options.callback] = callbackName\n\n    oScript\n        .setAttribute(&#39;src&#39;, url + &#39;?&#39; + format(data))\n    oBody.append(oScript)\n\n    function format(data) {\n        let str = &#39;&#39;\n        for (var p in data) {\n            str += encodeURIComponent(p) + &#39;=&#39; + encodeURIComponent(data[p]) + &#39;&amp;&#39;\n        }\n        return str\n    }\n}\n</code></pre>\n<p>例子：</p>\n<pre><code class="lang-js">jsonp({\n    url: &#39;https://sp0.baidu.com/5a1Fazu8AA54nxGko9WTAnF6hhy/su&#39;,\n    type: &#39;get&#39;,\n    data:{\n        wd: &#39;jsonp&#39;\n    },\n    callback: &#39;cb&#39;,\n    success: function (data) {\n         console.log(data)\n     }\n});\n</code></pre>\n<p>实现jsonp有三种方法 但是其实实质是一样的 ，都是利用script的跨域请求能力。\n（都需要后端进行配合，将callback和数据拼接成string）</p>\n<ol>\n<li>直接用script标签 在请求地址后面加上callback参数 ，在这之前必须先定义改callback函数</li>\n<li>使用上面的封装的方法 动态创建一个script标签</li>\n<li>使用jquery 的ajax方法 ，设置参数 dataType:&#39;jsonp&#39;,jsonocallback之类的参数 就可以了 ，其实质也是创建一个script标签 和2一样。</li>\n</ol>\n'},Petw:function(n,e){n.exports='<hr>\n<p>title: webpack配置各种loader\ndate: 2017-11-07 10:57:49</p>\n<h2 id="tags-webpack-">tags: [webpack]</h2>\n\x3c!-- deleteAbove --\x3e\n<p>一些常见的 css ，js ，image 的loader配置。</p>\n<p>小二 ， 上码 ！\n\x3c!-- more --\x3e</p>\n<h3 id="webpack-config-js">webpack.config.js</h3>\n<pre><code class="lang-js">var HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);\n\nmodule.exports = {\n    // 基础设置\n    devtool: &#39;eval-source-map&#39;,  // 生成  Source Maps  便于调试，会输出详细的错误信息\n    entry:  __dirname + &quot;/app/main.js&quot;,//唯一入口文件\n    output: {\n        path: __dirname + &quot;/dist&quot;,//打包后的文件存放的地方\n        filename: &quot;js/[name].js&quot;,//打包后输出文件的文件名\n        // publicPath:&quot;http://helloBitchs/&quot;,   // 打包之后在自动在引用的地方加前缀\n    },\n//  配置 server 实时应用修改更新并打包\n    devServer: {\n        contentBase: &quot;./public&quot;,//本地服务器所加载的页面所在的目录\n        historyApiFallback: true,//true不跳转  false刷新页面\n        port:&quot;5200&quot;,\n        hot: true,\n        inline: true//实时刷新\n    },\n    //  loader   各种类型的loader 都在这里配置 css js img\n    module: {\n        loaders: [\n            {       // js\n                test: /\\.js$/,\n                // exclude: /node_modules/,\n                include:/app/,\n                loader: &#39;babel-loader&#39;,\n                options: {\n                    &#39;presets&#39;: [&#39;latest&#39;],\n                }\n            },\n            //  css\n            {\n                test: /\\.css$/,\n                use: [\n                  &#39;style-loader&#39;,\n                  { loader: &#39;css-loader&#39;, options: { importLoaders: 1 } },\n                  &#39;postcss-loader&#39;\n                ]\n            },\n            //  less    less-loader,less\n            {\n                test: /\\.less$/,\n                use: [{\n                        loader: &quot;style-loader&quot; // creates style nodes from JS strings\n                    }, {\n                        loader: &quot;postcss-loader&quot;\n                    }, {\n                        loader: &quot;less-loader&quot; //注意顺序 要放最后面\n                }]\n            },\n            //  sass / scss  和less 的配置差不多       sass-loader,node-sass\n            {\n                test: /\\.scss$/,\n                use: [{\n                    loader: &quot;style-loader&quot; // creates style nodes from JS strings\n                }, {\n                    loader: &quot;css-loader&quot; // translates CSS into CommonJS\n                }, {\n                    loader: &quot;sass-loader&quot; // compiles Sass to CSS\n                }]\n            },\n            //  html\n            {\n              test: /\\.html?$/,\n              loader: &#39;html-loader&#39;,\n            },\n            {   // ejs 模板的loader  类似的模板loader还有很多 可在webpack官网查询\n              test: /\\.ejs?$/,\n              loader: &#39;ejs-loader&#39;,  //  html中的图片\n            },\n            {   //  markdown-loader\n                test: /\\.md$/,\n                loader:&quot;html-loader!markdown-loader&quot;\n            },\n            // {   // url-loader\n            //     // 比file-loader 多了一个功能 ，可限制图片的大小，\n            //     // 超过则是图片，不超则打包成base64\n            //     test: /\\.(gif|jpg|png|woff|svg|eot|ttf)\\??.*$/,\n            //     loader: &#39;url-loader?limit=5000&amp;name=images/[name].[ext]&#39;\n            // },\n            //\n            // file-loader\n            {   // css中和 html 中使用的图片 都会被loader处理\n                //  !!但是模板中的图片不会被替换!! 解决办法就是 使用require 引入图片到模板文件\n                test: /\\.(png|jpg|gif|svg)$/,\n                use: [\n                  {\n                    loader: &#39;file-loader&#39;,\n                    options: {\n                        name: &#39;[name].[ext]&#39;,\n                        outputPath: &#39;images/&#39;,\n                    }\n                  }\n                ]\n              }\n        ]\n  },\n\n    //  插件\n    plugins: [\n        new HtmlWebpackPlugin({                 //  打包后自动生成一个index.html 引用生成的js文件\n            template: __dirname + &quot;/public/index.html&quot;,// new 一个这个插件的实例，并传入相关的参数\n            inject:&quot;body&quot;,\n            fileName:&quot;index.html&quot;,\n        })\n    ]\n}\n</code></pre>\n<h3 id="postcss-">postcss 配置</h3>\n<p>可以使用很多个插件 具体插件配置 直接看<a href="https://github.com/michael-ciniawsky/postcss-load-config">官方文档</a>。</p>\n<p>postcss.config.js</p>\n<pre><code class="lang-js">// https://github.com/michael-ciniawsky/postcss-load-config\n\nmodule.exports = {\n  &quot;plugins&quot;: {\n    // to edit target browsers: use &quot;browserlist&quot; field in package.json\n    &quot;autoprefixer&quot;: {}\n  }\n}\n</code></pre>\n'},SKcX:function(n,e,t){"use strict";function o(n){t("7dfn")}var r=t("2VVp"),a=t("T6rQ"),s=t("ngHh"),i=o,l=s(r.a,a.a,!1,i,"data-v-2fad0128",null);e.a=l.exports},Shsg:function(n,e){n.exports='<hr>\n<p>title: hexo设置canvas背景\ndate: 2017-11-13 11:11:46\ntags: [hexo]</p>\n<h2 id="categories-hexo">categories: hexo</h2>\n\x3c!-- deleteAbove --\x3e\n<h3 id="hexo-canvas-">hexo 设置canvas背景</h3>\n<p>使用hexo 都会需要使用一个主题 theme ，不同的主题可能会内置不同的背景图片，\n以 NEXT 主题为例，相信其他的主题的背景 设置应该是一样的。</p>\n\x3c!-- more --\x3e\n<h4 id="next-">NEXT 自带背景</h4>\n<p>在主题文件夹 hexo-theme-next  里面 有一个_config.yml 配置文件 在这里面 搜索 canvas_nest  可以看到下面 后面设置的是 false ，下面还有 好几个一样的设置，这些都是 NEXT 已有的背景，可以改为 true 来设置想要的背景 动画。</p>\n<h4 id="-">定制背景动画</h4>\n<ol>\n<li>紧接上面，在 _config.yml 文件 另加一个配置，例如：<pre><code>color-ribbon: true\n</code></pre></li>\n<li><p>在  source/lib 里面 添加一个文件夹以及对应的画canvas背景的js， 例如 color-ribbon/color-ribbon.js</p>\n</li>\n<li><p>在layout/_scripts/vendors.swig 里面搜 canvas_nest，然后把那一段 if 复制 一份 改成 color-ribbon</p>\n</li>\n</ol>\n<pre><code class="lang-js">{% if theme.color_ribbon %}\n  {% set js_vendors.color_ribbon  = &#39;color-ribbon/color-ribbon.js&#39; %}\n{% endif %}\n</code></pre>\n<p>然后 就可以在页面上看到效果了。</p>\n<p><strong>注意</strong>：</p>\n<blockquote>\n<p>创建 canvas 元素，添加css样式并添加入body的操作尽量用js，不然还需要修改 公共样式和common.swig 比较繁琐，也容易产生冲突。</p>\n<p>最后提供一些 canvas背景素材 ， 需要自己审查代码，找到其中的js文件  <a href="http://www.jq22.com/">canvas背景素材</a></p>\n</blockquote>\n'},SsN4:function(n,e,t){"use strict";e.a={}},T6rQ:function(n,e,t){"use strict";var o=function(){var n=this,e=n.$createElement;n._self._c;return n._m(0)},r=[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",[t("div",{staticClass:"footer"},[n._v("\r\n        这是页脚哦！\r\n    ")])])}],a={render:o,staticRenderFns:r};e.a=a},TPNm:function(n,e,t){"use strict";var o=t("VK9Y");t.n(o);e.a={data:function(){return{articleContent:""}},mounted:function(){var n=this.$route.params.id,e=t("ZCub")("./"+n+".md"),o=e.indexOf("\x3c!-- deleteAbove --\x3e");o>0&&(e=e.substring(o+"\x3c!-- deleteAbove --\x3e".length)),this.articleContent=e}}},U9R1:function(n,e,t){"use strict";function o(n){t("JWwo")}var r=t("TPNm"),a=t("zMWb"),s=t("ngHh"),i=o,l=s(r.a,a.a,!1,i,"data-v-3a778548",null);e.a=l.exports},VK9Y:function(n,e){},YRjS:function(n,e){n.exports='<hr>\n<p>title: solr的简单使用-插入\ndate: 2017-12-22 10:42:53\ntags: [solr,java]</p>\n<h2 id="categories-solr">categories: solr</h2>\n\x3c!-- deleteAbove --\x3e\n<p>紧接上条博客，加上 插入数据的代码。</p>\n\x3c!-- more --\x3e\n<p>solr的配置在上篇文章已经写了。\n直接看代码吧 ：</p>\n<pre><code class="lang-java">public class insertData {\n    public static void main(String[] args)\n    {\n        BufferedReader br = null;\n        ApplicationContext ac = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);\n        SolrTemplate geoQueryTemplate= (SolrTemplate) ac.getBean(&quot;geoQueryTemplate&quot;);\n        String filePath = &quot;C:\\\\Users\\\\userlqq\\\\Desktop\\\\aa.csv&quot;;\n        String connection = &quot;geo&quot;;  \n        try\n        {\n            DataInputStream csv = new DataInputStream(new FileInputStream(new File(filePath)));\n            br = new BufferedReader(new InputStreamReader(csv,&quot;GBK&quot;));\n        } catch (FileNotFoundException | UnsupportedEncodingException e)\n        {\n            e.printStackTrace();\n        }\n        String line = &quot;&quot;;\n        try {\n                int all = 0;\n                int n = 10000;\n                List&lt;GeoPosition&gt; ls = new ArrayList();\n                while ((line = br.readLine()) != null)  //读取到的内容给line变量\n                {\n                    // 处理数据\n                    String[] lineInfo = line.split(&quot;\\\\|&quot;);\n                    if(lineInfo.length &lt; 5){\n                        System.err.println(&quot;出错了：&quot;+line);\n                        continue;\n                    }\n                    GeoPosition a = new GeoPosition();\n                    a.setCategory(lineInfo[0]);\n                    a.setId(lineInfo[1]);\n                    a.setLocation(lineInfo[2]+&quot;,&quot;+lineInfo[3]);\n                    a.setName(lineInfo[4].endsWith(&quot;,&quot;) ? lineInfo[4].substring(0, lineInfo[4].length()-1) : lineInfo[4]);\n                    a.setPosition(lineInfo[2]+&quot;,&quot;+lineInfo[3]);\n                    //  存储\n                    ls.add(a);\n                    //  每  n 个 插入一次\n                    if(ls.size()==n){\n//                        System.out.println(&quot;commit一次,目前总数:&quot;+all);\n                        geoQueryTemplate.saveBeans(connection, ls);\n                        geoQueryTemplate.commit(connection);\n                        ls.clear();\n                    }\n                    all++;\n                }\n                if(ls.size()&gt;0){\n                    System.out.println(&quot;最后一次:&quot;+ls.size());\n                    geoQueryTemplate.saveBeans(connection, ls);\n                    geoQueryTemplate.commit(connection);\n                }\n                System.out.println(all+&quot;条数据已经插入完成！&quot;);\n        } catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>\n<p><strong>流程</strong></p>\n<p>首先读取excel文件 用while循环 将每条记录稍加处理后存入bean ，在将bean存入临时数组，当数组长度到达10000的时候 ，进行一次 批量导入（saveBeans） 在清空数组，重新填充。这样能极大的加快插入速度</p>\n<p>在这里遇到了几个错误 ，都是url地址的问题 最终 在 saveBeans和commit方法都指定了 库名 才解决了问题。</p>\n<p>如果遇到问题 ，请再三确认请求的地址是否错误。</p>\n<p>接下来就可以去solr 的 web页面查看有没有数据了。</p>\n'},YaEn:function(n,e,t){"use strict";var o=t("O534"),r=t("dNqC"),a=t("gHLv"),s=t("U9R1");o.a.use(r.a),e.a=new r.a({routes:[{path:"/",name:"home",component:a.a},{path:"/article/:id",name:"article",component:s.a}]})},ZCub:function(n,e,t){function o(n){return t(r(n))}function r(n){var e=a[n];if(!(e+1))throw new Error("Cannot find module '"+n+"'.");return e}var a={"./2017年10月书单.md":"zNqw","./Spring一些常用的注解.md":"FHfX","./Spring视图重定向.md":"HQu0","./hexo设置canvas背景.md":"Shsg","./jsonp跨域请求的封装.md":"NJ3n","./js中不同数据类型的加法.md":"h62p","./js中的this.md":"jx6N","./js中的浅复制和深复制.md":"2DAM","./solr的简单使用-插入.md":"YRjS","./solr的简单使用.md":"+gQr","./vue深入响应式原理.md":"c3J+","./webpack配置各种loader.md":"Petw","./虚拟节点VNode.md":"HLh+","./输入url之后发生了什么.md":"ESBp"};o.keys=function(){return Object.keys(a)},o.resolve=r,n.exports=o,o.id="ZCub"},"c3J+":function(n,e){n.exports='<hr>\n<p>title: vue深入响应式原理\ndate: 2017-10-9 15:23</p>\n<h2 id="tags-vue-">tags: [vue,响应式,问题]</h2>\n\x3c!-- deleteAbove --\x3e\n<h2 id="-">深入响应式原理</h2>\n<p>现在的MVVM框架 基本都有响应式系统 ，数据的改变驱动着视图的改变，这种设计让状态管理变得非常简单\n\x3c!-- more --\x3e\n1.\n<img src="https://cn.vuejs.org/images/data.png" alt="响应式原理"></p>\n<p>2.\n<img src="http://static.galileo.xiaojukeji.com/static/tms/shield/vue-reactive.jpg" alt="响应式原理"></p>\n<h3 id="-">原理解析</h3>\n<p>传给vue实例<em>data</em>的对象中存着所有实例初始化的变量，Vue会遍历这些属性并且对于每一个属性使用 <em>Object.defineProperty</em> 把这些属性全转换为<em>getter/setter</em>，这两个方法 <strong>用户是无法调用的</strong> ，只能在Vue内部，当某一个属性被修改，便会调用setter ，setter里面便会通知watcher，watcher会进一步的重新计算页面，然后调用render方法，修改virtual dom 再修改页面。</p>\n<blockquote>\n<p>watcher就像是一个中间人 ，将<strong>更新页面</strong>和<strong>setter</strong>连接起来。</p>\n</blockquote>\n<p>详细的过程就是图2中的流程，通过Observer、Dep、Watcher、Directive将数据与视图连接起来.具体的描述请看        <a href="http://www.imooc.com/article/14466">这里</a></p>\n<p>通过Watcher把上述两部分结合起来，即把Directive中的数据依赖通过Watcher订阅在对应数据的 Observer 的 Dep 上。当数据变化时，就会触发 Observer 的 Dep 上的 notify 方法通知对应的 Watcher 的 update，进而触发 Directive 的 update 方法来更新 DOM 视图，最后达到模型和视图关联起来。、</p>\n<h3 id="-">代码实现</h3>\n<p>vue的响应式原理主要是依赖了 <strong>Object.defineProperty()</strong> 方法。这就是 ie8及以下的浏览器不支持vue的原因。</p>\n<p>接下来看看 vue将data转为可观察数据的方法的简单实现：</p>\n<pre><code class="lang-js">function observer(value, cb) {\n    Object.keys(value).forEach((key) =&gt; defineReactive(value, key, value[key] , cb))\n}\n\nfunction defineReactive (obj, key, val, cb) {\n    Object.defineProperty(obj, key, {\n        enumerable: true,\n        configurable: true,\n        get: ()=&gt;{\n            /*....依赖收集等....*/\n        },\n        set:newVal=&gt; {\n            cb();/*回调*/\n        }\n    })\n}\n\nclass Vue {\n    constructor(options) {\n        this._data = options.data;\n        // 在初始化的时候调用 observe 将所有data 数据转为可观察（observable）的\n        observer(this._data, options.render)\n    }\n}\n\nlet app = new Vue({\n    el: &#39;#app&#39;,\n    data: {\n        text: &#39;text&#39;,\n        text2: &#39;text2&#39;\n    },\n    render(){\n        console.log(&quot;数据变化&quot;);\n    }\n})\n</code></pre>\n<p>首先将 data 赋值给_data，在将_data 通过 observe()方法重新定义，加上 <strong>setter</strong> 和 <strong>getter</strong>.</p>\n<blockquote>\n<p>这个例子展示的只是 对于单个元素的监测  <strong>数组</strong>的监测会稍有不同，需额外方法 observeArray () 事实上也就是循环对数组每个元素 进行监测 请看<a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/index.js">源码</a></p>\n</blockquote>\n<p>到这为止，_data的数据变成了响应式数据 但不是 vm.data ,所以这里还需要一个代理:</p>\n<pre><code class="lang-js">_proxy(options.data);/*构造函数中*/\n\n/*代理*/\nfunction _proxy (data) {\n    const that = this;\n    Object.keys(data).forEach(key =&gt; {\n        Object.defineProperty(that, key, {\n            configurable: true,\n            enumerable: true,\n            get: function proxyGetter () {\n                return that._data[key];\n            },\n            set: function proxySetter (val) {\n                that._data[key] = val;\n            }\n        })\n    });\n}\n</code></pre>\n<p>这个代理的作用其实就在于给 data 也加上了 getter  和  setter  然后在它们里面 触发this._data的setter和getter方法。</p>\n<p><strong>现在已经对data 加上监测了  那么监测到变化之后怎么触发视图更新呢？</strong></p>\n<p>这里会涉及到几个 概念 ：</p>\n<ul>\n<li>dep</li>\n<li>watcher</li>\n</ul>\n<p>Dep 类是一个简单的观察者模式的实现。</p>\n<pre><code class="lang-js">\nexport default class Dep {\n  static target: ?Watcher;\n  id: number;\n  subs: Array&lt;Watcher&gt;;\n\n  constructor () {\n    this.id = uid++\n    this.subs = []\n  }\n  //在定义getter 时调用 添加到watcher\n  addSub (sub: Watcher) {\n    this.subs.push(sub)\n  }\n\n  //......\n\n  // 在setter时调用，数据改变 -&gt; 遍历所有的订阅 Watcher，调用它们的 update 方法\n  notify () {\n    // stabilize the subscriber list first\n    const subs = this.subs.slice()\n    for (let i = 0, l = subs.length; i &lt; l; i++) {\n      subs[i].update()\n    }\n  }\n}\n</code></pre>\n<p>subs 存储着所有的watcher，watcher 的方法看<a href="http://www.imooc.com/article/14468">这里</a></p>\n<p>现在回过头看上面的两张图 应该更能理解了。</p>\n<p><strong>问题:</strong></p>\n<blockquote>\n<p>为什么不直接在data上面设置 setter 和 getter 呢？</p>\n</blockquote>\n<h4 id="-">参考文章：</h4>\n<ul>\n<li><p><a href="https://github.com/answershuto/learnVue/blob/master/docs/%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%86%8D%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A.MarkDown">从源码角度再看数据绑定</a></p>\n</li>\n<li><p><a href="http://www.imooc.com/article/14466">深入响应式原理</a></p>\n</li>\n</ul>\n'},gHLv:function(n,e,t){"use strict";function o(n){t("2AXw")}var r=t("w/JX"),a=t("BEmW"),s=t("ngHh"),i=o,l=s(r.a,a.a,!1,i,"data-v-63bd23c3",null);e.a=l.exports},h62p:function(n,e){n.exports='<hr>\n<p>title: js中不同数据类型的加法\ndate: 2017-09-27 17:15</p>\n<h2 id="tags-js-">tags: [js,数据类型]</h2>\n<h2 id="-deleteabove-">\x3c!-- deleteAbove --\x3e</h2>\n<h3 id="-">前言</h3>\n<p>在js 中 有5中基础类型 undefined null boolean number string  和一种引用类型 object</p>\n<p>不同类型之间的加法是怎么进行的呢 ？</p>\n\x3c!-- more --\x3e\n<p>ex:  a+b</p>\n<h3 id="-">步骤</h3>\n<ol>\n<li>首先对加号两边的 a,b 进行  ToPrimitive()操作  转换成原始值 也就是 专门对于object的。如果是个原始值（基础类型）,直接返回，如是 object,\n<strong>先尝试valueOf()方法 ，如果返回的是原始值，就返回 ；如果不是，继续使用toString(),如果是原始值就返回 ，再不是就抛错(一般不会出现)</strong></li>\n</ol>\n<p>也就是 ：  valueOf  &gt;  toString  &gt;  error</p>\n<ol>\n<li><p>接下来 等号两边都是原始值了，先看看有没有string类型的 如果有 那就把另一个也弄成string 然后字符串拼接</p>\n</li>\n<li><p>如果都不是，就转成数字number类型 再相加</p>\n</li>\n</ol>\n<blockquote>\n<p>附表</p>\n</blockquote>\n<p>各类型转 string</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>&quot;undefined&quot;</td>\n</tr>\n<tr>\n<td>null</td>\n<td>&quot;null&quot;</td>\n</tr>\n<tr>\n<td>布尔值</td>\n<td>&quot;true&quot;  或者 &quot;false&quot;</td>\n</tr>\n<tr>\n<td>数字</td>\n<td>数字作为字符串,比如. &quot;1.765&quot;</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>无需转换</td>\n</tr>\n</tbody>\n</table>\n<p>各类型转 number</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>undefined</td>\n<td>NaN</td>\n</tr>\n<tr>\n<td>null</td>\n<td>+0</td>\n</tr>\n<tr>\n<td>布尔值</td>\n<td>true被转换为1,false转换为+0</td>\n</tr>\n<tr>\n<td>数字</td>\n<td>无需转换</td>\n</tr>\n<tr>\n<td>字符串</td>\n<td>由字符串解析为数字.例如,&quot;324&quot;被转换为324</td>\n</tr>\n</tbody>\n</table>\n<p>数组 和 对象的 valueOf</p>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th>结果</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>[1,2,3]</td>\n<td>[1,2,3]</td>\n</tr>\n<tr>\n<td>{a:&quot;a&quot;}</td>\n<td>{a:&quot;a&quot;}</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>都会返回原值 除非，手动修改了对象的 valueOf 属性</p>\n</blockquote>\n<p>数组 和 对象的 toString()\n参数    |    结果\n---|---\n[1,2,3]   |    &#39;1,2,3&#39;\n{a:&quot;a&quot;}    | &quot;[object Object]&quot;</p>\n<blockquote>\n<p>对象都会返回&quot;[object Object]&quot;，包括空对象 {} ，  除非手动修改了对象的 valueOf 属性</p>\n</blockquote>\n<h3 id="-">题目</h3>\n<blockquote>\n<p>思考</p>\n</blockquote>\n<pre><code class="lang-js">\n[]+[]\n\n{}+{}  \n\n{}+[]\n\n[]+{}\n\n({}+{})\n</code></pre>\n<h3 id="-">另外</h3>\n<p>简单类型都放在栈（stack）里\n对象类型都放在堆（heap）里\n不同的对象是不等的所以有：</p>\n<pre><code class="lang-js">[]==[]   // false\n</code></pre>\n<p>参考文章：</p>\n<ul>\n<li>[<a href="https://github.com/jawil/blog/issues/1">https://github.com/jawil/blog/issues/1</a>]</li>\n</ul>\n'},i3Kz:function(n,e,t){"use strict";var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{attrs:{id:"app"}},[t("Header"),n._v(" "),t("div",{attrs:{id:"articlecontainer"}},[t("router-view")],1),n._v(" "),t("Footer")],1)},r=[],a={render:o,staticRenderFns:r};e.a=a},jx6N:function(n,e){n.exports='<hr>\n<p>title: js中的this\ndate: 2017-09-28 13:52</p>\n<h2 id="tags-js-this-">tags: [js,this]</h2>\n\x3c!-- deleteAbove --\x3e\n<blockquote>\n<p>this的指向，是在函数被调用的时候确定的，记住这句话有利于理解this</p>\n</blockquote>\n\x3c!-- more --\x3e\n<h2 id="-">不同情况下有不同的取值</h2>\n<p>以下分为6种情况：</p>\n<ul>\n<li><p>this在全局范围内</p>\n</li>\n<li><p>this在对象的构造函数内</p>\n</li>\n<li><p>this在对象的方法内</p>\n</li>\n<li><p>this在一个简单的函数内</p>\n</li>\n<li><p>this在箭头函数内</p>\n</li>\n<li><p>this在一个事件侦听器内</p>\n</li>\n</ul>\n<h3 id="this-">this在全局范围内</h3>\n<p>全局范围 this 指向两种情况：</p>\n<p>浏览器 --&gt; window  </p>\n<p>nodejs--&gt; global</p>\n<h3 id="this-">this在对象的构造函数内</h3>\n<pre><code>function Man(name){\n    this.name\n}\nvar i = new Man(&quot;lqq&quot;);\n</code></pre><p> 那这里的this 就是指向 i 的，每个实例都有自己的this，互不影响。</p>\n<h3 id="this-">This在对象的方法内</h3>\n<pre><code>let o = {\n    getName(){\n        console.log(this.name);\n    },\n    name:&quot;lqq&quot;\n}\n\no.getName() // &quot;lqq&quot;\n</code></pre><p>这里的this 指的就是 o ，</p>\n<h3 id="this-">This在一个简单的函数内</h3>\n<p>在浏览器中, 简单函数里面的this总是被指向Window. 即使你在对象的方法中调用一个简单函数, 在这个简单函数里面的this也是指向Window.</p>\n<pre><code>\nfunction simpleFunction() {\n    console.log(this);\n}\n\nvar o = {\n    sayThis() {\n        simpleFunction(); // 如果把这句替换成console.log(this);那就输出的是 o\n    }\n}\n\nsimpleFunction(); // Window\no.sayThis(); // Window\n</code></pre><h3 id="this-">This在箭头函数中</h3>\n<p>this在箭头函数中总是跟它在箭头函数所在作用域的this一样(在它直接作用域).</p>\n<p>以, 如果你在对象中使用箭头函数, 箭头函数中的this总是指向这个对象本身：</p>\n<pre><code>var o = {\n    doSomethingLater() {\n        setTimeout(() =&gt; this.speakLeet(), 1000);\n    },\n    speakLeet() {\n        console.log(`1337 15 4W350M3`);\n    }\n}\n\no.doSomethingLater(); // `1337 15 4W350M3`\n</code></pre><p>setTimeout本来里面的this是指向window的 这里是箭头函数，所以this被强行改成指向 o了</p>\n<blockquote>\n<p>改变任何函数(方法)中的this值的方法还有bind, call或者apply.</p>\n</blockquote>\n<h3 id="this-">This在事件侦听器内</h3>\n<p>在事件侦听器内, this被指向的是触发这个事件的元素:</p>\n<p>转自：[<a href="https://zhuanlan.zhihu.com/p/28704724">https://zhuanlan.zhihu.com/p/28704724</a>]</p>\n'},n8Kv:function(n,e,t){"use strict";var o=t("SKcX"),r=t("Mitt"),a=t("qOrV");t.n(a);e.a={name:"app",components:{Header:r.a,Footer:o.a}}},"oFz+":function(n,e){},qOrV:function(n,e){},vAWj:function(n,e,t){"use strict";var o=(t("O534"),t("Br8G")),r=t.n(o),a=t("EPnm"),s=(t.n(a),{});s.install=function(n,e){n.directive("highlight",function(n){n.querySelectorAll("pre code").forEach(function(n){r.a.highlightBlock(n)})})},e.a=s},"w/JX":function(n,e,t){"use strict";var o=t("Hzjv");e.a={data:function(){return{list:o}},methods:{genUrl:function(n){return"/article/"+n.replace(/\.md/g,"")},genTitle:function(n){return n.replace(/\.md/g,"")}}}},zMWb:function(n,e,t){"use strict";var o=function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"articleInfo"},[t("div",{staticClass:"title"},[n._v(n._s(n.$route.params.id))]),n._v(" "),t("article",{directives:[{name:"highlight",rawName:"v-highlight"}],staticClass:"article",domProps:{innerHTML:n._s(n.articleContent)}})])},r=[],a={render:o,staticRenderFns:r};e.a=a},zNqw:function(n,e){n.exports='<hr>\n<p>title: 2017年10月书单\ndate: 2017-10-27 14:56:53\ntags: [书单]</p>\n<h2 id="categories-reading">categories: reading</h2>\n\x3c!-- deleteAbove --\x3e\n<p>我想开始把自己看的一些书记录下来了，没有每周必看几本书的目标，也没有看书必写感悟的决心。</p>\n<p>只是一个程序员工作之余的读书随笔。</p>\n<p>书 ，不限种类，不限字数，一切从心（怂。。。哈哈）\n\x3c!-- more --\x3e</p>\n<h3 id="10-">10 月 书 单</h3>\n<h4 id="-">《围城》</h4>\n<blockquote>\n<p>人生是围城，婚姻是围城，进去了，就被生存的种种烦愁包围。城里的人想出来，城外的人想进去。</p>\n<p>爱情与性欲一胞双生，类而不同，性欲并非爱情的基本，爱情也不是性欲的升华。</p>\n<p>旅行是最劳顿，最麻烦，叫人本相毕现的时候。经过长期艰苦旅行而不彼此讨厌的人，才可以结交朋友</p>\n<p>我们一生对于最亲爱的人的想念，加起来恐怕不到一点钟，此外不过是念头在他身上瞥过，想到而已。</p>\n<p>从前愚民政策是不许人民受教育，现代愚民政策是只许热敏受某一种教育。</p>\n</blockquote>\n<p>其实对于很多未知事物，人都很向往，不止婚姻。没有得到之前，它看上去是多么的美好，但是得到之后，接触之后，也就发现了其中令人抗拒的糟粕。当你是在忍受不了了，就想逃离。</p>\n<p>婚姻 ， 爱情 ，性这三者又有什么必然的联系吗？</p>\n\x3c!-- 看完这本书，对于这三者也有了一点思考。我现在是有点抗拒婚姻的，是因为看了书中的例子，我怕了？ 不 ，应该是对于婚姻没有那么憧憬了吧。初恋结束后，对于结婚已经失去了那股傻劲了。如果可以的话 ，我会尽量晚点结婚，这么年轻的时候，不想被家庭压着，才刚从大学出来，开始自己的独立生活，实在不想再回到那种状态。 就这样开心的享受一下，单身 或者 恋爱 不好吗？ 书中的男主角（方）也是这样想的吧，所以在回国的船上，即便知道她是有夫之妇，也知道她是在诱惑他，即使知道船一到，他们就要分别，他也愿意享受这段短暂的恋爱，或者叫暧昧。之后，又陷入了苏文纨和唐晓芙的三角恋。这时候的方还是选择爱情--唐晓芙，而不是家世显赫、海龟留学生的女神同学--苏文纨。虽然，之后被苏使计拆散而分手，苏的心里还是忘不了唐。因此，之后他不敢再爱了，他的婚姻也是 再一句气话中 决定了。这样的婚姻 自然是不会幸福的。后面的故事就全是一些鸡毛蒜皮的斗嘴，婚姻生活也没有丝毫的甜蜜可言。 --\x3e\n\x3c!-- 但是\n\n人不能被爱情打败。不能因为一次的失败，而把内心藏起来，这是懦弱。\n\nloving can hurt sometimes,but loving can mend your soul.\n\n我对于爱情还是很向往的 ， 初恋的时候不懂事，但是以后的恋情都能好好珍惜，不求终老，但求无悔。婚姻？滚你妈的，老子还没‘玩’够 ，我才不想进‘坟墓’呢！ --\x3e\n<h4 id="-">《解忧杂货铺》</h4>\n<p>东野圭吾，善于推理文学的作家，对于在书中给你一些意想不到的剧情极其擅长，在书中也会偶尔埋下一些伏笔，整本书刚开始看，觉得就只是讲个故事，知道看完，才将所有的故事联系在一起，整本书没有什么华丽辞藻，就是一些很平淡的话 在讲一个 不平凡的故事（这也是多亏了翻译做的好），最后面的几章逐渐的将故事线连接起来。让我想起了去年看的异步电视剧《西部世界》，那种最后一集的酣畅淋漓实在刺激。</p>\n<p>书中的每个小故事，其实都能引发读者的思考，每个故事中的烦恼其实都是读者们的烦恼。 爱情与梦想，梦想与现实..... 或多或少的会引发共鸣。</p>\n<p>下面是我记录的一些句子：</p>\n<blockquote>\n<p>心，一旦离开了，就再不会回来。</p>\n<p>其实所有纠结做选择的人心里早就有了答案，咨询只是想得到内心所倾向的选择。最终的所谓命运 还是自己一步步走出来的。</p>\n<p>其实很久以前我就知道自己应该怎样选择，只是一直无法下决心舍弃梦想。到现在，我依然不知道怎样才能做到这一点。打个比方，这就如同单相思的感觉，明知恋情不会有结果，却还是忘不了对方。</p>\n<p>我的回答之所以发挥了作用，原因不是别的，是因为他们自己很努力。如果自己不想积极认真地生活，不管得到什么样的回答都没用。</p>\n<p>无论现在多么的不开心，你要相信，明天会比今天更好。</p>\n<p>人与人之间情断义绝，并不需要什么具体理由，就算表面上有，也很可能只是心已经离开的结果，事后才编造出的借口而已。</p>\n</blockquote>\n\x3c!-- end --\x3e\n'}},["NHnr"]);
//# sourceMappingURL=app.8e8e220b24e4b561c3ba.js.map